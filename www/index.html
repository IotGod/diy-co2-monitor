<!DOCTYPE html>
<html>
  <script>
    let _graph_tmarkers = [];
    let _graph_tstrings = [];
    let _graph_pmarkers = [];
    function init() {
      /*
          setInterval(() => {
            upadte_data();
          }, 1000);
    */
      let r = JSON.parse(
        '{"ppm":795,"temp":31.00,"warming":1,"historical":{"span":60, "interval":10, "max":794, "min":747, "data":[794,793,790,789,787,785,783,782,781,779,776,775,774,772,771,770,769,768,767,765,764,762,762,760,760,759,759,758,758,757,756,756,756,755,755,756,755,753,752,751,750,750,748,748,748,748,747,747,747,747,747,747,747,747,747,747,748,747,747,747]}}'
      );
      ppm_update(r.ppm);
      graph_update(r.historical);
    }

    function upadte_data() {
      let request = new XMLHttpRequest();
      request.open("GET", "http://192.168.1.145/data", true);
      request.send();
      request.onreadystatechange = function () {
        if (request.readyState == 4 && request.status == 200) {
          ppm_update(JSON.parse(request.responseText).ppm);
        } else {
        }
      };
    }
    function ppm_update(ppm) {
      let text = document.getElementById("ppm_text");
      text.textContent = ppm;
      if (ppm > 999) text.attributes.x.nodeValue = 0;
      else text.attributes.x.nodeValue = 100;
    }
    function graph_update(historical) {
      let d = "";
      let svg_cords = document.getElementById("graph_svg").getBoundingClientRect();
      let w_height_factor = 0.8;
      let w_height = svg_cords.height * w_height_factor;
      let v_offset = (svg_cords.height * (1 - w_height_factor)) / 2;
      let h_step = svg_cords.width / historical.span;
      d += `M 0,${svg_cords.height.toFixed(2)}\r\n`;
      let pos = w_height * normalize(historical.max, historical.min, historical.data[0]);
      d += `0,${(w_height - pos).toFixed(2)}\r\n`;

      let t = 0;
      let x_pos = 0;
      for (t = 1; t < historical.data.length; t++) {
        pos = w_height * normalize(historical.max, historical.min, historical.data[t]);
        d += `${x_pos.toFixed(2)},${(v_offset + (w_height - pos)).toFixed(2)}\r\n`;
        x_pos += h_step;
      }
      x_pos -= h_step;
      d += `${x_pos.toFixed(0)}, ${svg_cords.height.toFixed(0)}\r\n`;

      let svg = document.getElementById("graph_svg");
      let el = document.createElementNS("http://www.w3.org/2000/svg", "path");
      el.setAttribute("d", d);
      el.setAttribute("fill", "url(#linearg)");
      el.setAttribute("fill-opacity", "0.3");
      el.setAttribute("stroke-linecap", "round");
      el.style.stroke = "blue";
      el.style.strokeWidth = "1px";
      svg.appendChild(el);
    }

    function normalize(max, min, val) {
      return (val - min) / (max - min);
    }
  </script>
  <style>
    @import url("https://fonts.googleapis.com/css?family=Roboto:400,400i,700,700i");
    body {
      text-align: center;
      padding: 0;
      margin: 0;
      width: calc(100vw - 2px);
      height: calc(100vh - 2px);
      overflow: hidden;
      font-family: Roboto, sans-serif;
      color: #5b636a;
    }
    svg {
      border: 1px solid transparent;
    }
    #top-wrapper {
      width: 100%;
      height: 100%;
      max-width: 1920px;
      max-height: 1080px;
      border: 1px solid transparent;
      margin: auto;
      display: flex;
      flex-direction: column;
    }
    #header {
      border: 1px solid transparent;
      width: 100%;
      height: 48px;
    }
    #mid-wrapper {
      width: 100%;
      height: calc(60% - 96px);
      border: 1px solid transparent;
      display: flex;
    }

    #ppm-section {
      width: calc((100% / 3) * 2);
      height: 100%;
      border: 1px solid transparent;
    }
    #ppm-section h1 {
      font-size: 25.5vw;
      margin: 0;
    }
    #aside {
      width: calc((100% / 3) * 1);
      height: 100%;
      border: 1px solid #5b636a;
    }
    #graph-section {
      width: 100%;
      height: 50%;
      border: 1px solid transparent;
    }

    #footer {
      border: 1px solid #5b636a;
      width: 100%;
      height: 48px;
      position: absolute;
      display: none;
      bottom: 0px;
    }
    @media only screen and (max-width: 1024px) {
      #ppm-section {
        width: 100%;
      }
      #aside {
        display: none;
      }
      #graph-section {
        height: calc(45% - 48px);
      }

      #footer {
        display: block;
      }
    }
  </style>
  <body onload="init()">
    <div id="top-wrapper">
      <header id="header"></header>
      <div id="mid-wrapper">
        <section id="ppm-section">
          <svg
            width="100%"
            height="100%"
            viewBox="0 0 500 75"
            preserveAspectRatio="xMinYMid meet"
            style="background-color: white"
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
          >
            <defs>
              <style>
                @import url("https://fonts.googleapis.com/css?family=Roboto:400,400i,700,700i");
              </style>
            </defs>
            <text id="ppm_text" x="0" y="90" font-size="175" fill="#5b636a" font-family="Roboto, sans-serif">0000</text>
            <text x="400" y="100" font-size="45" fill="#5b636a" font-family="Roboto, sans-serif">ppm</text>
          </svg>
        </section>
        <aside id="aside"></aside>
      </div>
      <section id="graph-section">
        <svg id="graph_svg" preserveAspectRatio="none" width="100%" height="100%" viewBox="0 0 1920 540">
          <defs>
            <style>
              @import url("https://fonts.googleapis.com/css?family=Roboto:400,400i,700,700i");
            </style>
          </defs>
          <!-- <linearGradient id="linearg" x1="0%" y1="0%" x2="100%" y2="0%"> -->
          <linearGradient id="linearg" x1="0%" y1="0%" x2="0%" y2="100%">
            <stop offset="0%" style="stop-color: rgb(0, 140, 255); stop-opacity: 1" />
            <stop offset="100%" style="stop-color: rgb(255, 255, 255); stop-opacity: 0" />
          </linearGradient>
        </svg>
      </section>
      <footer id="footer"></footer>
    </div>
  </body>
</html>
